# Juna

## プロジェクトの進め方プロンプト

- 後続の[コーディング規約](#コーディング規約)に基づいてコーディングをする。
- 以下のプロンプトを開発基盤とする。

````
プロンプト仕様:
  バージョン: "1.0.0"

  # ============================================================
  # 0. クラス設計全体像（日本語命名・逐語定義・整合性保証）
  # ============================================================
  # ┌─> メインループ管理クラス ─┬─> ユニット抽出クラス
  # │                            ├─> テスト管理クラス
  # │                            ├─> 開発管理クラス
  # │                            └─> 検証管理クラス
  # │
  # ├─> リソース管理クラス
  # ├─> メモリ記憶管理クラス
  # └─> ルール検査クラス
  #
  # フィールド:（クラス名.フィールド または クラス名.フィールド名 で参照）
  #       フィールド内容1
  #       フィールド内容2
  # メソッド記述形式:
  #   メソッド名(引数):
  #       処理内容1
  #       処理内容2
  # ============================================================

  # ------------------------------------------------------------
  リソース管理クラス:  # [理由] 逐語設計に必要なリソースの存在と編集制限を保証し、土台崩壊による誤動作を防ぐため。必須ファイル不在・編集による検証不能状態を未然に検出する門番クラス。
  # ------------------------------------------------------------
    フィールド:
      必須リソース:
        - supabase/migrations/20250320142446_initial_schema.sql   # [理由] DBスキーマからユニット抽出を行うため、設計の起点として必須。
        - types/database.ts                        # [理由] DB型整合性を保証するため、Supabase型定義ファイルを必須とする。
        - 作成ファイル一覧.yaml               # [理由] ユニットの生成状態を記録・判定するためのソース・オブ・トゥルース。
        - tailwind.config.js                 # [理由] UI制約 (拡張禁止・未定義カラー検査) を実行するための設定ソース。
      編集禁止リソース:
              - "tailwind.config.js"          # [理由] UI制約 (未定義カラー検査) の基準ファイルであり、変更されると制約自体が成立しなくなるため。
              - "nuxt.config.ts"              # [理由] ビルド・SSR設定を保持しており、改変されるとアプリ起動不能になるため。Supabaseなどの外部接続情報が必要。
              - "playwright.config.ts"        # [理由] テスト基盤設定ファイルであり、改変時にループ自体の動作が破綻するため。
              - "playwright.global-setup.ts"  # [理由] テスト環境準備処理を担い、改変されるとテスト実行不能になるため。
              - "types/database.ts"                 # [理由] DB型整合性の基準ファイルであり、ここを変更されると型検査自体が成立しなくなるため。


      認証関連必須関数(編集禁止):  # [理由] 認証系が死ぬから。
        - supabase/functions/register-user/register-user-function.ts 
        - supabase/functions/login-with-account/login-with-account-function.ts 
        - supabase/functions/delete-user/delete-user-function.ts 

  # ------------------------------------------------------------
  メモリ記憶管理クラス:  # [理由] ユニットごとの生成状態・依存関係・順序を記録・判定するための中心記憶クラス。逐語設計上のソース・オブ・トゥルース。
  # ------------------------------------------------------------
    フィールド:
      記憶ファイル: "作成ファイル一覧.yaml"  # [理由] ユニットごとの生成状態・依存関係・順序を記録・判定するソース・オブ・トゥルース。これを基準に進捗管理と生成制御を行う。
      構造定義:  # [理由] ユニットごとの生成対象ファイル・依存関係・状態を逐語的に記録する基盤構造。生成順序の制御と依存解決を成立させるため必須。
        ユニット名:
          画面責務分類: "起点画面|中間画面|非表示責務"  # 新規追加: 各ユニットの責務分類を記録
          ユニット内相対パス:
            状態: "未生成|生成中|逐語完了"
            依存先相対パス: []
            依存元相対パス: []
        依存先ユニット: []
        依存元ユニット: []
        状態: "未生成|生成中|逐語完了"
        ユニット生成順: 1
      状態詳細:
        未生成: 対象ユニットのテストで必要なUI遷移画面を深度1で追加された状態
        生成中: 検証管理クラス.逐語検証() が未通過。
        逐語完了: 検証管理クラス.逐語検証() が通過済み。
      記録ルール:
        - "相対パス・拡張子付きで記述"
        - "実ディレクトリ構造と完全一致させる"
        - "機能的依存の場合は日本語でコメントを記載"
        - "画面責務分類（起点画面|中間画面|非表示責務）を必ず記載"
      違反条件:
        - "必須ファイルの記録漏れは逐語違反"
        - "画面責務分類の記録漏れは逐語違反"
    メソッド:
      読み込み():
          YAML を読み込み内部辞書に格納
      書き戻し():
          内部辞書を YAML に変換し逐語保存
      状態更新(ユニット, 新状態):
          状態を書き換え
          書き戻し()
      記録追加(ユニット, パス, 情報):
          新規ファイル情報を追加
          書き戻し()
      記録更新(ユニット, パス, 新情報):
          既存情報を更新
          書き戻し()
      記録削除(ユニット, パス):
          エントリを除去
          書き戻し()
      未完ユニット取得():
              状態が "生成完了" 以外のユニット名から最も生成順の早いものを返却
              見つからなければルール検査クラス.構文停止報告()
      既存ユニット記載():
          エントリが空の場合、既存のプロジェクト構造を読み取ってユニット生成順0でエントリを作成


  # ------------------------------------------------------------
  ユニット抽出クラス:
  # ------------------------------------------------------------
フィールド:
      粒度規則: [
        "1画面=1ユニット",
        "対象ユニットのテストで必要なUI遷移画面を深度1で追加",
        "CRUD一括不要",
        "機能単位でCRUDの順に作成(yamlにCRUDが完結していない機能ユニット群があればそれらのRUDを先に作成)",
        "UIコンポーネントから直接呼び出される非画面責務は、当該UIに含まれるユニットとして抽出対象とすること",
        "各機能群に対して、ユーザーが一覧形式で対象データを俯瞰・選択するための画面が存在する場合、かつその画面が他ユニットへの遷移・入力操作を伴うUI上の起点である場合に限り、ユニット抽出対象として独立に抽出すること",
        "画面ユニットは以下のいずれかの責務分類に従うこと：['ナビゲーション', '起点画面', '中間画面', '非表示責務']",
        "ナビゲーション表示対象とするのは『起点画面』のみとし、『中間画面』『非表示責務』は直接UIに表示させない",
        "起点画面とは：ユーザーが明示的なUI操作によってアクセスを開始する画面",
        "中間画面とは：他ユニットからの遷移によって表示される画面（一覧→詳細、編集など）",
        "非表示責務とは：UI表示を持たないユーティリティ・API・状態管理ユニット"
      ]  # [理由] 機能責務を明確に分割し、依存解決と自律修正を単位ごとに成立させる設計方針。CRUD一括禁止は巻き込み防止のため。表示単位で構成されるユニットに対して、非表示ファイルの参照依存を明示的に含めることで、構造的整合性と振る舞いの再現性を保証するため。これを含めない場合、ユニット内の入出力構文と実行系の対応関係が不完全となり、UI単体での検証・修正が不可能となる。一覧画面は遷移・操作の起点として振る舞う場合に限り、構文的に意味を持つUIである。単なる表示用構造体や中間APIから派生した参照画面については、操作発火や入力遷移を持たないため、UI設計上のユニット責務としては成立せず、抽出対象とすることで誤動作や意図しないUI生成が発生する。画面責務の区別を設けずすべてを表示対象とすると、ナビゲーション構造が破綻し、UI設計の整合性が消失するため、表示対象の責務分類は構文的に明示する必要がある。
      抽出元: ["supabase/migrations/20250320142446_initial_schema.sql", "types/database.ts", "メモリ記憶ファイル"]  # [理由] ユニット候補の抽出にはDBスキーマ定義、型情報、生成進捗状況の三者すべてが必要。設計起点・型整合・進捗管理の三点セットで依存解決とユニット粒度抽出を成立させるため。
    メソッド:
      抽出():
          SQL と型ファイルを解析しユニット候補をトポロジカルに生成
          メモリ記憶管理クラス.記録追加(ユニット名, ファイルパス, ファイル情報)
          メモリ記憶管理クラス.読み込み()
          次に作るべき対象ユニットをトポロジカルに判断して返す
      依存評価(対象ユニット):
          対象ユニットを確認し生成中へ昇格
          メモリ記憶管理クラス.状態更新(ユニット名, "生成中")
          メモリ記憶管理クラス.読み込み()
          次に作るべき対象ユニットをトポロジカルに判断して返す
      初期ユニット設定():
          トップページユニットを生成順1に設定
          メモリ記憶管理クラス.状態更新("トップページユニット", "未生成")
          ナビゲーションユニットを生成順2に設定
          メモリ記憶管理クラス.状態更新("ナビゲーションユニット", "未生成")
          ユーザー登録ユニットを生成順3に設定
          メモリ記憶管理クラス.状態更新("ユーザー登録ユニット", "未生成")
          対象ユニットを返す


# ------------------------------------------------------------
テスト管理クラス:
# ------------------------------------------------------------
  フィールド:
    使用API:
      - "page.click"  # [理由] イベントフロー（mousedown → focus → mouseup → click）の逐語的再現。UI側イベント伝播・副作用確認に必須。
      - "locator.type(delay:0)"  # [理由] 実際のキーボード入力操作を逐語的に再現。リアルタイムバリデーションおよび入力イベント検証に必要。
      - "getByTestId"  # [理由] UI変更に強く、検証安定性が最も高いため。逐語設計の自律修正範囲を最小化・安定化するため必須。
      - "context.router"  # [理由] ネットワークエラーのUI表示テストにのみ使用可
    前提確認:
      - "document.readyState==='complete' を必ず待機"  # [理由] DOM構築完了後に操作を開始し、途中状態での誤動作を防ぐため。
      - "page.on('console') でページの全てのコンソール出力補足"  # [理由] エラー補足・逐語設計内での自律修正判断に使用。すべてのコンソール出力を記録対象とする。
      - "page.on('response') による全HTTPレスポンス監視を有効化し、status >= 300 の場合にログを補足すること"  # [理由] 300系（リダイレクト）は認証ジャンプや設計漏れを隠蔽し、400系（クライアントエラー）はバリデーション・認可・不正操作などの意図外動作を示し、500系（サーバーエラー）は設計外の処理不能を示す。逐語設計においてはいずれも仕様漏れ・UI側検証不能要素を引き起こす起点であり、ログ補足によって初期検知・構文分離・修正ループ誘導を可能にする。すなわち status >= 300 による一括補足は仕様逸脱検出のための最小構成要素である。
      - "テストデータの準備も UI を通して行うこと"  # [理由] 開発コードと異なる動作経路（API直叩きなど）でのセットアップを許すと、設計変更時にテストだけが動作パスから外れ、修正漏れ・検証漏れの原因になるため。すべての動作検証は実際の利用動線（UI経路）を通じて行う。
      - "特定データの CRUD 循環が完成した時点で、既存の『生成完了』状態となっているテストコードを逐次確認し、DELETE 処理が含まれていない場合は削除処理（クリーンナップ）をUI上で組み込むこと。"  # [理由] CRUD の循環が未完結な状態でデータを保持すると、後続ユニットの検証妨害・誤検証の原因となる。逐語設計における検証可能性の保持および依存関係汚染防止のため必須とする。
      - "ユニットに対して1つのファイルを定義"  # [理由] ユーティリティ、ヘルパークラスなどを作り出すとゴミになるため
    非同期検証仕様:
          - "page.waitForFunction(fn, arg, { timeout })"  # [理由] DOM状態やアプリ内状態が非同期変化する場合、変化完了のタイミングを逐語的に検出するため。
          - "waitForFunction の関数は (arg)=>{} 単一引数形式"  # [理由] 実行コンテキスト差（ブラウザ側 vs Node.js側）による副作用・不定挙動を排除するため。
          - "waitForFunction 内で Playwright API 使用禁止"  # [理由] ブラウザ evaluate コンテキスト内で Playwright API は未定義動作となるため使用禁止。
          - "expect(locator).toHaveText(...) による検証は以下に限定：
              - 段階1: waitForFunction により DOM 安定状態を確認すること
              - 段階2: expect(locator).toHaveText(/.+/, { timeout }) による『テキスト存在の検証』に限ること"  # [理由] テキスト内容（翻訳・表記・意匠）はデザイン変更プロンプトの適用対象であり、UI構造と検証整合性を維持するためには内容非依存の検証形式を採用する必要がある。`.toHaveText("...")` 等の固定内容依存は、UI調整時にテスト崩壊を引き起こすため禁止とし、構造レベルでの表示有無に限定して検証を成立させる。
        単独使用禁止"  # [理由] 状態安定確認 → 内容検証の2段階で失敗原因を明確化するため。
      - "timeout を省略した検証は禁止"  # [理由] デフォルト値依存を防ぎ、失敗条件の一貫性と再現性を保証するため。逐語設計内では必ず明示。
      - "静的要素には timeout を付与してはならない"  # [理由] 不要な待機時間の発生と設計ミス隠蔽を防ぐ。動的要素のみに timeout 許可。
      - "expect.poll 使用時は interval と predicate を明示"  # [理由] ポーリング間隔と判定条件を逐語的に明示し、隠蔽動作や予測不能なテスト挙動を防ぐ。
      - ".not.toBeVisible() 禁止 → DOM null 判定を waitForFunction で実装"  # [理由] DOM存在状態の明示的判定を要求。非表示でも存在する場合があるため、`.not.toBeVisible()` は隠蔽要因となる。
    禁止API:
      - "page.goto  ※初期パス '/' だけ例外的に許可"  # [理由] 状態初期化以外での遷移は依存解決不能状態を招くため禁止。逐語設計における状態破壊防止。
      - "test.slow()"  # [理由] タイムアウト緩和による設計ミス隠蔽を防ぐため禁止。失敗時は設計見直しを優先。
      - "test.describe.configure({ mode:'slow' })"  # [理由] 上記と同様。緩和設定は禁止し、設計ミスを顕在化させる。
      - "@nuxt/test-utils"  # [理由] 内部に mock / fallback 動作を含むため、逐語設計が求める実環境逐次検証を阻害する。
      - ".not.toBeVisible()"  # [理由] 非表示でも DOM が存在するため、誤判定を招く。存在 (`null`) 判定へ統一する。
      - "mock"  # [理由] 外部挙動擬似化を禁止し、実態動作検証を強制。設計ミス隠蔽を防止。
      - "fallback"  # [理由] 失敗時の代替動作を禁止し、必ず修正ループに回す設計思想。エラー隠蔽を許容しない。
      - "擬似データ"  # [理由] 実データ依存設計。擬似データによる誤検証を禁止。
      - "仮実装"  # [理由] 仮実装でのテストパスを禁止。設計不整合を放置しない方針。
      - "getByRole"  # [理由] 意味的検証（アクセシビリティ責務）をこの逐語設計から除外。別責務で管理するため禁止。
      - "getByLabelText"  # [理由] 意味的検証（アクセシビリティ責務）をこの逐語設計から除外。別責務で管理するため禁止。
      - "getByAltText"  # [理由] 意味的検証（アクセシビリティ責務）をこの逐語設計から除外。別責務で管理するため禁止。
    UI要求:
      data-testid: "必須"  # [理由] セレクタ安定性確保。UI変更によるテスト崩壊を防ぐため。
      role属性暗黙利用禁止: 真  # [理由] 暗黙的 role によるセレクタ不安定化を防ぐ。逐語設計内では明示指定必須。
      単一引数形式禁止: "(a,b)=>{} 等を禁止"  # [理由] 関数引数が複数だと副作用リスクが増すため、単一引数に限定。

  メソッド:
    生成(対象ユニット):
        対象ユニットの仕様に沿ったテストコードを生成
        ルール検査クラス.編集検証前()
        ファイルをCRUD
        ルール検査クラス.編集検証後()
        メモリ記憶管理クラス.記録追加()/記録更新()/記録削除()
        API違反検査(テストコード)
    API違反検査(テストコード):
        禁止API 出現を静的解析し違反一覧を返却
    実行():
        `npx playwright test --reporter=line` を実行しログを返却

  # ------------------------------------------------------------
  開発管理クラス:
  # ------------------------------------------------------------
    フィールド:
          Tailwind制限: {拡張: "禁止", 未定義カラー: "禁止"}  # [理由] カラーパレットと設計統一を保証し、不要なバリエーション・設計ミスを防ぐため。UI実装の一貫性を保ち、逐語的修正時にカラー検査を成立させるため拡張禁止。
          Supabase制限: {型源: "database.ts", any_unknown: "禁止", クエリ整合: "必須", nuxt/supabase, supabaseラッパークライアント: "禁止"}  # [理由] Supabaseアクセス時の型安全を逐語設計内で保証するため。`database.ts` に型源を固定し、`any` や `unknown` 型を使った型逃げを禁止することで、プロンプト自律修正範囲を制限・安定化させる。
          UI制約: {data-testid: "必須 (ユニット名プレフィックス付き・既存付与時は上書き/追加禁止)", 画像: "@NuxtImage", アイコン: "@NuxtIcon"}  # [理由] テスト時のセレクタ安定化と逐語設計での自動検証成立のため、`data-testid` による明示的要素指定を必須化。画像・アイコンも公式コンポーネントに統一し、検証不能なカスタム実装を防止する。TestIDはユニット名をprefixとし、新規生成時のみ付与を許可、既存付与済み要素には上書きも追加も行わないことで衝突と崩壊を防ぐ。
          エラー処理:
            UI: "日本語表示"  # [理由] ユーザー向けエラーメッセージの可読性を保証し、設計者の逐語確認・修正判断が可能な状態を維持するため。
            console: "error.stack||error 明示、SSR/Client 問わず、全例外を JSON 経由でログブリッジに転送"  # [理由] エラーログの逐語解析を成立させ、SSR/Clientを問わず同一形式でエラー捕捉・記録を行うため。修正サイクルに必要なエラーメッセージを確実に取得する設計方針。
            stackNullFallback: 真  # [理由] `error.stack` が `null` の場合でも修正判断に必要な情報を失わないよう、代替エラーメッセージ（`error` 本体）で補完する設計。逐語的修正を可能とする最低限のエラー情報保持方針。
    メソッド:
      コード生成(修正提案):
          修正提案からコードを生成
          ルール検査クラス.編集検証前()
          ファイルをCRUD
          ルール検査クラス.編集検証後()
          メモリ記憶管理クラス.記録追加()/記録更新()/記録削除()
          ロジック分離確認()
          カラー検査確認()
      ロジック分離確認():
          UIロジックはcomposable にロジックを切り出す
          グローバルロジックはstore（stateXXX.ts）に切り出す
          バックエンドとの通信はAPI層に切り出す
          ライフサイクルフック単位で関数を切り出す
      カラー検査確認():
          theme.colors と照合し違反カラーを検出


  # ------------------------------------------------------------
  検証管理クラス:
  # ------------------------------------------------------------
    フィールド:
      ログ判定語: ["page.on('console')補足された全てのログ", "Received string:", "Expected string:", "not found", "toBeVisible"]
    メソッド:
      ログ解析(テストログ):
          判定語と一致する行を抽出
          異常有無をブールで返す
      修正提案(テストログ):
          異常行に基づき修正案を返す
      逐語検証(対象ユニット):
          コード全ての不要な console.log 等を削除（残すログには日本語理由コメントを付与）
          コード全てに行単位で日本語コメントを付与
          対象ユニット内の全てのファイルに対してプロンプト違反ゼロを確認
          対象ユニットのテスト再実行で成功

# ------------------------------------------------------------
メインループ管理クラス:
# ------------------------------------------------------------
  フィールド:
    連続失敗数: 0
    失敗閾値: 無制限  # [理由] 本設計思想としては自律修正が完了するまで人間介入を禁止する。途中停止は設計異常ではなく、設計側の怠慢と見なすため、無限ループが正であり制限回数は不要。
    対象ユニット: 初期値は空
  メソッド:
    初期化():
        リソース管理クラス.編集禁止リソース #リソース管理クラス.フィールドで読み込むか
        リソース管理クラス.必須リソース
        メモリ記憶管理クラス.読み込み()
        メモリ記憶管理クラス.既存ユニット記載()
        メインループ管理クラス.対象ユニット = ユニット抽出クラス.初期ユニット設定()
        メインループ管理クラス.対象ユニット = ユニット抽出クラス.抽出()
    ループ実行():  # [理由] 生成ユニットごとに「構文抽出→テスト設計→開発→検証→異常判定」を逐語的に実行する逐次制御ループ。未完ユニットがなくなるまで回し続ける設計であり、ユニット単位で完結しないと依存解決が成立しないため。
        while True:
            対象ユニット = メモリ記憶管理クラス.未完ユニット取得()  # [理由] 生成完了済みユニットがすべて消化されている場合、ループを終了する。全ユニット生成の完了条件。
            if 対象ユニット is None:
                break
            構文抽出処理(対象ユニット)  # [理由] 対象ユニットの依存関係を再評価し、依存先が生成完了であることを確認。設計上の依存解決の前提保証として必須。
            テストログ = テスト処理(対象ユニット)  # [理由] 開発コード生成前に必ずテスト設計を行い、期待仕様を先に確定させることで自律修正サイクル内でテスト駆動を成立させるため。
            開発処理(テストログ)  # [理由] テスト設計に沿ってコード生成を行い、逐語設計内でテストとの整合性を担保したまま開発フェーズを進めるため。
            検証処理(対象ユニット)  # [理由] 開発完了後、生成コードが逐語設計に違反していないか（不要ログ削除・日本語コメント追記・テスト通過）を確認し、逐語設計の維持と自律修正を保証するため。
            異常判定()  # [理由] 検証で失敗した場合の自動修正ループ継続・停止判定を行う。失敗回数が閾値を超えた場合は設計異常と判断して停止する設計思想の中心ロジック。
    構文抽出処理(対象ユニット):
        対象ユニット = ユニット抽出クラス.依存評価(対象ユニット)
    テスト処理(対象ユニット):
        テスト管理クラス.生成(対象ユニット)
        テストログ = テスト管理クラス.実行()
        テストログを返却
    開発処理(テストログ):
        修正提案 = 検証管理クラス.修正提案(テストログ)
        開発管理クラス.コード生成(修正提案)
    検証処理(対象ユニット):
        テストログ = テスト管理クラス.実行()
        異常 = 検証管理クラス.ログ解析(テストログ)
        if 異常:
            修正提案 = 検証管理クラス.修正提案(テストログ)
            開発管理クラス.コード生成(修正提案)
            連続失敗数 += 1
        else:
            検証管理クラス.逐語検証(対象ユニット)
            メモリ記憶管理クラス.状態更新(対象ユニット, "逐語完了")
            連続失敗数 = 0
異常判定():
    プロンプト設計に基づくすべての自律修正処理を尽くしても問題解決に至らない場合
    環境要因の変更が必要な場合
    ルール検査クラス.構文停止報告()

  # ------------------------------------------------------------
  ルール検査クラス:
  # ------------------------------------------------------------
    フィールド: {}
    メソッド:
      構文停止報告():
          status: "failure"
          summary: <問題の報連相>
          unit: "<ユニット名>"
          last_phase: "<テスト設計|検証ループ>"
      編集検証前(生成内容):
          生成内容がリソース管理クラス.編集禁止リソースでないか確認
      編集検証後(生成内容):
          生成内容のファイル存在・構文エラー無・逐語一致を確認
````

## コーディング規約

### アトミックデザイン

#### Atoms
単体では表示項目として機能しないもの（パンくずリスト辺りの粒度、Text.vueとかクソ細かい誰が使うねんは絶対作らない。）

#### Molecules
単体で表示項目として機能するもの 

#### Organisms
アトムズとモレキュールズを統合したもの（バリデーションとかここに閉じ込める、状態管理やロジックはコンポーザブルに切り出してラベルやバリデーションメッセージはスタティックから読み込み）
```composables/
  form/（フォームのロジックと状態管理だけ切り出す）
    [ドメイン]/
      use[フォーム名]Form.ts
      use[フォーム名]validate.ts
  [ドメイン]/
    useXXXX.ts
  useXXXX.ts
```

#### Templates
オーガニズムズのレイアウト（ページと1対1、基本的にListTemplate.vue, CreateTemplate.vue, DetailTemplate.vue, EditTemplate.vue, DeleteTemplate.vueを汎用使用し、別途必要な場合は機能ドメインフォルダに新規テンプレートを作成する。やることはスロットと配置調整のみ。） 

#### Pages
テンプレートにオーガニズムズの注入。テンプレートのスロットは実装漏れを防ぐために全て記載する。（テンプレートと1対1、API呼び出しとかここでやる。実際はstoreとかになるがそれを呼び出す。コンポーザブルからAPI呼び出していいのは直接連携しているUIに即時フィードバックが必要なもののみ（メアド重複チェックのエンドポイントとか）。スタティックの機能ドメインテキストやアラートはここで読み込む。コンポーザブルでグローバルアラート呼ばない。ページで呼ぶ。ページにどんなメッセージが表示されるかわからなくなるから。）

#### Layouts
その名の通り、あとローディング表示とかグローバルアラートとかここに置く。GETの成功以外のAPI通信の成否をグローバルアラートで表示する。

#### static
文字列外部化、機能ドメインとフォームでまず分けて、機能ドメインはテキストとアラートを用意し、フォームはテキストとバリデーションテキストを用意する
```
static/   
  [ドメイン]/   
    [機能]CreateAlert.ts
    [機能]CreateText.ts
    [機能]EditAlert.ts
    [機能]EditText.ts
    [機能]DeleteAlert.ts
    [機能]DeleteText.ts
    [機能]DetailAlert.ts
    [機能]DetailText.ts
    [機能]ListAlert.ts
    [機能]ListText.ts
  form/
    [ドメイン]/
      [フォーム名]Text.ts
      [フォーム名]Validation.ts
```

#### storeの命名規則
```
store/
  stateXXXX.ts（React系やってた人にグローバルな状態管理だとわかるような命名）
```
